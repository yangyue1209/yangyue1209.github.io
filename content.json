{"pages":[{"title":"自我感觉良好","text":"比较宅，喜欢静静地研究一些关于前端的小知识… 喜欢猫…","path":"about/index.html","date":"11-15","excerpt":""},{"title":"404","text":"页面不存在","path":"404/index.html","date":"11-15","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"11-15","excerpt":""}],"posts":[{"title":"API接口与Web端口的区别","text":"API接口与Web端口的区别API全名（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节说的大白话一些就是为了方便开发人员使用的便利工具。而webservice走HTTP协议和80端口。API需要同时开发客户端API和服务器端程序。 而WebService只需要开发服务器端，不需要开发客户端。","path":"2018/11/15/API接口与Web端口的区别/","date":"11-15","excerpt":""},{"title":"innerHTML与document.createElement的优缺点","text":"innerHTML与document.createElement的优缺点innerHTML：优点：可以指定位置创建元素 进行复杂结构创建时操作较为简便: 缺点：覆盖问题(解决不了)：虽然尝试使用+=方式解决，但是只能解决结构的问题，没有获取到所有的事件等内容。 性能问题(已解决)： 假如我们给box内部动态创建200个空div: console.time(‘innerHTML’); var box = document.getElementById(&apos;box&apos;); for (var i = 0; i &lt; 200; i++) { box.innerHTML += &apos; &apos;; } console.timeEnd(&apos;innerHTML&apos;); 通过对比，我们看到innerHTML进行元素创建操作的执行速度慢，具有性能问题。 上面的小测试创建200个div用时155.400146484375ms innerHTML属性执行效率问题的解决方式： 避免使用innerHTML重复执行多次(不在循环中使用即可) (以下两种方式任选其一即可) 1 使用字符串替代执行 - 2ms左右console.time(&apos;innerHTML&apos;); var box = document.getElementById(&apos;box&apos;); var str = &apos;&apos;; for (var i = 0; i &lt; 200; i++) { str += &apos; &apos;; } box.innerHTML = str; console.timeEnd(&apos;innerHTML&apos;); 2 使用数组替代执行 - 2ms左右console.time(&apos;innerHTML&apos;); var box = document.getElementById(&apos;box&apos;); var arr = []; for (var i = 0; i &lt; 200; i++) { arr.push(&apos; &apos;); } box.innerHTML = arr.join(&apos;&apos;); console.timeEnd(&apos;innerHTML&apos;); document.createElement() - 用于创建一个元素- 参数：字符串形式的标签名称 效果：创建的元素默认不在页面中显示，需要根据实际的需求，添加到页面中的某个位置上。 var box = document.getElementById(‘box’); for (var i = 0; i &lt; 200; i++) { var div = document.createElement(&apos;div&apos;); box.appendChild(div); } console.timeEnd(&apos;createElement&apos;); 用时 4.1279296875ms - 用于与innerHTML做性能对比使用 缺点： - 如果使用document.createElement()创建复杂结构，操作较为繁琐 动态创建元素部分的小结：- 使用场景： - 如果结构复杂，使用innerHTML - 其他情况均可以使用document.createElement() - 如果要进行元素创建的结构内部已经具有其他元素，必须document.createElement()","path":"2018/11/15/innerHTML与document-createElement的优缺点/","date":"11-15","excerpt":""},{"title":"原型链","text":"原型链如何理解JavaScript中的原型和原型链 本文基于理解基础知识进行的拓展,并不会包含太多的基础知识。 首先是一张关系图,避免抽象化理解时产生的困难 Function对象 函数对象是JavaScript学习中不可避免的一部分,而且这一部分相对重要且抽象 函数的创建方式有2种: 字面量创建 varfoo=function(){console.log(“test”);} new 关键字创建实例对象 //let 函数名 = new Function(“参数列表”,”函数体”);letsum=newFunction(“num1,num2”,”return num1+num2”); 我们多数在使用new关键字的时候,是用于创建实例对象 那么我们首先来看一下,在使用new关键字创建实例对象的时候,都经历了什么: 创建一个新对象 将构造函数的作用域赋给新对象(this指向改变到实例对象中) 链接到原型对象,继承属性和方法 返回新对象 这个时候我们的关注点 原型对象 就出现了: 原型对象prototype prototype是一个显式原型属性(也可以叫它原型对象),只有函数才有该属性,通常我们叫这个时候的函数为”构造函数” prototype的伴随构造函数的声明就会被自动创建 原型对象prototype只有一个属性:constructor 代码举例: function Student (name,age) { this.name=name; this.age=age; } let s1 = new Student (“Tom”,17); 首先我们创建了一个构造函数Student,此时Student的结构中会出现一个prototype属性,即原型对象,这是引擎自动给它的,我们可以直接进行使用 实例对象prototype中的constructor属性: 此时可以看出constructor对应的是构造函数,也就是Student 并且这是一个公有不可枚举属性,一旦改变了prototype,这个属性就会不见,当然可以再手动添加回去 而当我们再使用new关键字创建实例对象s1之后,我们来看一下s1的结构: 实例对象s1中除了在Student获得的age,name属性之外,还有一个proto属性,所以它又是什么东西呢? proto是什么 proto是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型对象prototype,但是 prototype是内部私有属性,我们并不能访问到,所以使用proto进行访问 至于proto是如何产生的,上面的new关键字创建函数的时候的第三部”链接到原型,继承属性和方法”的时候就让实例对象,例如s1拥有了proto属性 从实例对象s1的proto指向构造函数Student的prototype,构成了原型链 通过原型链的概念,我们就不难理解实例对象是如何继承构造函数中原型对象的属性和方法了 function Student (name,age){ this.name=name; this.age=age; } Student.prototype.method = function () { console.log(&quot;我的名字是&quot;+this.name+&quot;,我的年龄是&quot;+this.age); } let s1 = new Student (“Tom”,17); s1.method(); //我的名字是Tom,我的年龄是17 深思考:底层的函数是如何创建出来的 从第一张关系图中以及后面的说明,我们可以知道Function.proto === Function.prototype是成立的,并且Function.prototype和Function.proto都指向Function.prototype 那么Function到底是谁创建出来的呢?是它自己创建了自己吗? 并不是 在解释这个问题前,我们要先说一下Object JavaScript中所有对象都可以通过原型链一层一层的最终找到 Object.prototype(原型链顶端),虽然 Object.prototype 也是一个对象，但是这个对象却不是 Object 创造的，而是JavaScript引擎自己创建了 Object.prototype 所以可以推论出 所有实例都是对象，但是对象不一定都是实例 紧接着再说回Function的创建问题 在控制台打印一下Function和Function.prototype 在JavaScript引擎首先创建了 Object.prototype之后 ，又创建了 Function.prototype，并且通过 proto 将两者联系了起来 既然Function.prototype 是JavaScript引擎创建出来的对象,所以就没有”到底是先有鸡还是先有蛋”这样的悖论问题出现 同样可以推导出:并不是所有的实例对象(函数)都是通过 new Function 方式创建出来的 这是一种比较严谨的说法,因为在通过字面量创建函数的时候就不会调用 函数构造器,也就是说它并不是new出来的,也就不存在这样的情况 至于说为什么Function.proto === Function.prototype,有种说法是为了不产生混乱,就把二者链接在了一起 在JavaScript的函数和对象的学习中,剖析其中关系网时,真的会让人上瘾,想要一层一层的去搞清楚弄明白,而且只有在理清了其中每一层的对应关系时才会对它们有一个更加清晰的认知,在使用的时候也会更加的自信,解决开发问题的时候更加的灵活和优雅","path":"2018/11/15/原型链/","date":"11-15","excerpt":""},{"title":"几道有趣的面试题","text":"几道有趣的面试题 var a; var b = a * 0; if (b == b) { console.log(b * 4 + &apos;2&apos; - 0 + 2); } else { console.log(!b * 4 + &apos;2&apos; - 0 + 2);// !b = 1; } 解答： a声明为赋值，结果为undefined b=a*0，undefined*0结果为 NaN ，NaN与NaN不相等故而执行else里的代码 b隐式转换布尔值为false ，而false转换为数字为0，故而!b=1； 所以不难得出结果为44. 2. var obj = {proto : {a:1,b:2}}; function F () {}; F.prototype = obj.proto; var f = new F(); obj.proto.c = 3; obj.proto = {a:-1,b:-2}; console.log(f.a); console.log(f.c); delete F.prototype[&apos;a&apos;]; console.log(f.a); console.log(obj.proto.a); 解答： F为构造函数 ，第三行代码将obj的proto属性赋给了F的原型， 而f为F的实例对象，故而f.a结果为obj里的a的值，也就是1； 而复杂数据类型直接传递的是指针，也就是说在obj的proto中加入 属性c，那么F的原型中也会有c属性，故而f.c的值为3； 在F的原型中删除了a属性，f为F的实例对象，故而删除 之后f.a的值为undefined； 而后obj的指针方向发生了改变，所以obj.proto.a的结果为 -1； 3. &lt;ul&gt; &lt;li id=&quot;1&quot;&gt;1&lt;/li&gt; &lt;li id=&quot;2&quot;&gt;&lt;/li&gt; &lt;li id=&quot;3&quot;&gt;1&lt;/li&gt; &lt;li id=&quot;4&quot;&gt;&lt;/li&gt; &lt;li id=&quot;5&quot;&gt;&lt;/li&gt; &lt;li id=&quot;6&quot;&gt;&lt;/li&gt; &lt;li id=&quot;7&quot;&gt;1&lt;/li&gt; &lt;/ul&gt; var lis = document.getElementsByTagName(&apos;li&apos;); for (var i = 0; i &lt; lis.length; i++) { if (lis[i].innerHTML == &apos;&apos;) { lis[i].parentNode.removeChild(lis[i]); } } 因为少了一个i--； 所以当i = 0的时候检查失败继续执行，i=1时检查成功删除索引为1的li结构，i从2开始查找 id为5的但是内容为空的li最后被剩下了 4.输出结果是多少 ( function test () { var a = b = 5; var c = 5, d = 5; e = 5; console.log(a) //自调用 函数内部都是5 console.log(b) console.log(c) console.log(d) console.log(e) })(); console.log(a) //报错 console.log(b) //隐式全局变量 5 console.log(c) //函数外访问不到 所以是报错了 console.log(d) //函数外访问不到 所以是报错了 console.log(e) ////隐式全局变量 5 5. 输出 结果是什么 var a = { name: &apos;小明&apos; }; var b = a; a = { name: &apos;小王&apos; }; console.log(a.name); console.log(b.name); a重定向，指针发生了改变，原来的指针复制给了b，所以a.name为小王， b.name为小明 6.输出 结果是什么 if (!(&quot;t&quot; in window)) { var t = 1; } console.log(t); 输出 结果是 undefined 代码的含义是 如果window里没有t这个 属性就声明t并赋值1 但是 ==&gt; js引擎会将var 提前 那么相当于代码变为 var t ; if (! &apos;t&apos; in window) { t = 1; } console.log(t); 声明提前之后，if 语句的判断结果为false，所以永远不会执行。故而结果为undefined","path":"2018/11/15/几道有趣的面试题/","date":"11-15","excerpt":""},{"title":"Infinity的几个出现场景以及一些简单计算操作的注意事项","text":"Infinity的几个出现场景以及一些简单计算操作的注意事项Number–js中的内置对象之一 ，在Number中 有这样两个属性： MAX_VALUE =========&gt;&gt;&gt;可表示的最大的数。它的近似值为 1.7976931348623157 x 10的308次方。 如果 数值超过了计算机可显示的最大数值，则返回Infinity，同理负数返回的为-Infinity； MIN_VALUE =========&gt;&gt;&gt;可表示的最小的正数。 MIN_VALUE 属性是 JavaScript 中可表示的最小的数（接近 0 ，但不是负数！！！）。它的近似值为 5 x 10的-324次方。 js中没有无穷小这个概念，所以无法表示比MIN_VALUE 小且大于0的数字，这就是为什么在数学组1/∞可以表示无穷小，但是在计算机中1/Infinity的返回值为0的原因。 我在下面总结了一些常用的数学计算方法返回值为非正常显示数值的情况： 1.乘法计算①. 如果 操作数都是数值的情况，执行 乘法计算（*）的时候，如果乘积超过了ECMAScript数值的表示范围则返回Infinity或-Infinity； ②. 如果是Infinity与0相乘，返回结果NaN; ③.Infinity与非0数值相乘 返回结果为Infinity或-Infinity； ④.Infinity与Infinity相乘返回结果Infinity； ⑤.如果一个 操作数为NaN ，则返回结果为NaN（）； ⑥.如果一个操作数不是数值，则后台会默认调用Number（）隐式转换后操作，然后引用上面的规则。 2.除法计算js中的除法计算与乘法计算相似，唯一注意的是在表示无穷小的时候，因为js中并没有无穷小的概念，所以数学方法中的无穷小=1/无穷大的概念行不通。所以1 / Infinity 的结果为0，除此之外，非零的有限数被0除，结果为Infinity或者-Infinity； 3.加法计算js中简单数据类型应用中，不止Number类型可以进行加法计算，String类型也可以，利用+进行字符串拼接操作，所以在进行加法计算之前一定要分清楚要计算的操作数属于什么类型，然后在进行计算，否则得出的结果天差地别。 ①.Infinity与Infinity相加结果为Infinity； ②.-Infinity加-Infinity结果为-Infinity； ③. 需要 注意一点，Infinity与-Infinity相加结果不是0，而是NaN； ④. 0虽然不分正负，但是在控制台输出的时候会有+0和-0的不一样的显示效果。所以0+0的结果为0，而-0 + -0的结果为-0； ⑤.另外一个需要注意的地方是如果一个操作数为字符串，则会默认将另外一个数值进行隐式转换然后进行字符串拼接操作。 ⑥.如果第一个操作数为字符串，我们在其前面加上一个+可以尝试将其进行隐式的Number类型转换： 如：console.log(+”10”) 其输出结果为数字类型的10； 而如果是console.log(“10”+0) 则结果为字符串类型的100； 如果是console.log(0+”10”+0)则输出结果为字符串0100； ⑦.如果有一个操作数为NaN，则返回结果为NaN； 4.减法计算与加法操作类似；","path":"2018/11/15/Infinity的几个出现场景以及一些简单计算操作的注意事项/","date":"11-15","excerpt":""},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2018/11/15/hello-world/","date":"11-15","excerpt":""}]}